import os
from pathlib import Path
import gi
gi.require_version('Gst', '1.0')
from gi.repository import Gst

import setproctitle
import hailo
import numpy as np
from PIL import Image, ImageDraw, ImageFont

from hailo_apps.hailo_app_python.core.common.installation_utils import detect_hailo_arch
from hailo_apps.hailo_app_python.core.common.core import get_default_parser, get_resource_path
from hailo_apps.hailo_app_python.core.common.defines import RESOURCES_VIDEOS_DIR_NAME
from hailo_apps.hailo_app_python.core.common.defines import SIMPLE_DETECTION_VIDEO_NAME
from hailo_apps.hailo_app_python.core.common.defines import SIMPLE_DETECTION_APP_TITLE
from hailo_apps.hailo_app_python.core.common.defines import SIMPLE_DETECTION_PIPELINE
from hailo_apps.hailo_app_python.core.common.defines import RESOURCES_MODELS_DIR_NAME
from hailo_apps.hailo_app_python.core.common.defines import RESOURCES_SO_DIR_NAME
from hailo_apps.hailo_app_python.core.common.defines import SIMPLE_DETECTION_POSTPROCESS_SO_FILENAME
from hailo_apps.hailo_app_python.core.common.defines import SIMPLE_DETECTION_POSTPROCESS_FUNCTION
from hailo_apps.hailo_app_python.core.gstreamer.gstreamer_helper_pipelines import INFERENCE_PIPELINE
from hailo_apps.hailo_app_python.core.gstreamer.gstreamer_helper_pipelines import USER_CALLBACK_PIPELINE
from hailo_apps.hailo_app_python.core.gstreamer.gstreamer_app import GStreamerApp
from hailo_apps.hailo_app_python.core.gstreamer.gstreamer_app import app_callback_class

SOURCE_FOLDER__TOPVIEW = "/home/brisk/netdrive/01-Organize/01-Management/01-Data Center/Brisk/06-AI & Machine Learning (D0340)/04-IOT_Smartfarm/picture_topview_smartfarm"
SOURCE_FOLDER__SIDEVIEW = "/home/brisk/netdrive/01-Organize/01-Management/01-Data Center/Brisk/06-AI & Machine Learning (D0340)/04-IOT_Smartfarm/picture_sideview_smartfarm"

def get_latest_image(folder_path: str) -> str:
    files = [os.path.join(folder_path, f) for f in os.listdir(folder_path)
             if f.lower().endswith((".jpg", ".jpeg", ".png"))]
    if not files:
        raise FileNotFoundError(f"No images found in {folder_path}")
    latest_file = max(files, key=os.path.getmtime)
    return latest_file

class user_app_callback_class(app_callback_class):
    def __init__(self):
        super().__init__()
        self.current_source = "topview"  # Track current source

def app_callback(pad, info, user_data):
    user_data.increment()
    frame_count = user_data.get_count()
    
    source_type = user_data.current_source
    string_to_print = f" Frame {frame_count} ({source_type.upper()}): "
    
    buffer = info.get_buffer()
    if buffer is None:
        return Gst.PadProbeReturn.OK

    detections = hailo.get_roi_from_buffer(buffer).get_objects_typed(hailo.HAILO_DETECTION)

    if detections:
        caps = pad.get_current_caps()
        structure = caps.get_structure(0)
        width = structure.get_value("width")
        height = structure.get_value("height")

        detection_results = []
        for detection in detections:
            bbox = detection.get_bbox()
            label = detection.get_label()
            confidence = detection.get_confidence()

            x1 = int(bbox.xmin() * width)
            y1 = int(bbox.ymin() * height)
            x2 = int(bbox.xmax() * width)
            y2 = int(bbox.ymax() * height)

            detection_info = {
                'label': label,
                'confidence': confidence,
                'bbox': (x1, y1, x2, y2),
                'source': source_type
            }
            detection_results.append(detection_info)

            string_to_print += f" {label} ({confidence:.0%}) "

        print(string_to_print)
        
        # Print detailed detection info
        for det in detection_results:
            print(f"   {det['source'].upper()}: {det['label']} - Confidence: {det['confidence']:.2f} - Box: {det['bbox']}")
            
    else:
        print(f"{string_to_print} No detections")

    return Gst.PadProbeReturn.OK

class GStreamerDetectionApp(GStreamerApp):
    def __init__(self, app_callback, user_data, parser=None):
        if parser is None:
            parser = get_default_parser()
        parser.add_argument(
            "--labels-json",
            default=None,
            help="Path to custom labels JSON file",
        )
        parser.add_argument(
            "--source-type",
            choices=["topview", "sideview", "both"],
            default="both",
            help="Which source to process: topview, sideview, or both",
        )
        super().__init__(parser, user_data)

        self.video_width = 640
        self.video_height = 360
        self.batch_size = 1

        nms_score_threshold = 0.3
        nms_iou_threshold = 0.45

        if self.options_menu.arch is None:
            detected_arch = detect_hailo_arch()
            if detected_arch is None:
                raise ValueError("Could not auto-detect Hailo architecture. Please specify --arch manually.")
            self.arch = detected_arch
            print(f" Auto-detected Hailo architecture: {self.arch}")
        else:
            self.arch = self.options_menu.arch

        if self.options_menu.hef_path is not None:
            self.hef_path = self.options_menu.hef_path
        else:
            self.hef_path = get_resource_path(
                pipeline_name=SIMPLE_DETECTION_PIPELINE,
                resource_type=RESOURCES_MODELS_DIR_NAME,
            )
        print(f" Using HEF path: {self.hef_path}")

        self.post_process_so = get_resource_path(
            pipeline_name=SIMPLE_DETECTION_PIPELINE,
            resource_type=RESOURCES_SO_DIR_NAME,
            model=SIMPLE_DETECTION_POSTPROCESS_SO_FILENAME
        )
        print(f"âš™ Using post-process shared object: {self.post_process_so}")

        self.post_function_name = SIMPLE_DETECTION_POSTPROCESS_FUNCTION
        self.labels_json = self.options_menu.labels_json
        self.source_type = self.options_menu.source_type
        self.app_callback = app_callback
        self.thresholds_str = (
            f"nms-score-threshold={nms_score_threshold} "
            f"nms-iou-threshold={nms_iou_threshold} "
            f"output-format-type=HAILO_FORMAT_TYPE_FLOAT32"
        )

        setproctitle.setproctitle(SIMPLE_DETECTION_APP_TITLE)
        
        if self.source_type == "both":
            self.process_both_sources()
        else:
            self.create_pipeline()

    def process_both_sources(self):
        print(" Processing both sources...")
        
        print("\n === PROCESSING TOPVIEW ===")
        self.user_data.current_source = "topview"
        self.current_source_folder = SOURCE_FOLDER__TOPVIEW
        self.create_pipeline()
        self.run()
        
        self.user_data = user_app_callback_class()
        self.user_data.current_source = "sideview"
        
        print("\n === PROCESSING SIDEVIEW ===")
        self.current_source_folder = SOURCE_FOLDER__SIDEVIEW
        self.create_pipeline()
        self.run()

    def get_pipeline_string(self):
        if hasattr(self, 'current_source_folder'):
            source_folder = self.current_source_folder
        elif self.source_type == "topview":
            source_folder = SOURCE_FOLDER__TOPVIEW
            self.user_data.current_source = "topview"
        elif self.source_type == "sideview":
            source_folder = SOURCE_FOLDER__SIDEVIEW
            self.user_data.current_source = "sideview"
        else:
            source_folder = SOURCE_FOLDER__TOPVIEW  # Default
            self.user_data.current_source = "topview"

        try:
            latest_img = get_latest_image(source_folder)
            print(f"Using latest image from {self.user_data.current_source}: {os.path.basename(latest_img)}")
        except FileNotFoundError as e:
            print(f"Error: {e}")
            raise

        source_pipeline = f"filesrc location=\"{latest_img}\" ! decodebin ! videoconvert"

        detection_pipeline = INFERENCE_PIPELINE(
            hef_path=self.hef_path,
            post_process_so=self.post_process_so,
            post_function_name=self.post_function_name,
            batch_size=self.batch_size,
            config_json=self.labels_json,
            additional_params=self.thresholds_str
        )
        user_callback_pipeline = USER_CALLBACK_PIPELINE()

        pipeline_string = (
            f"{source_pipeline} ! "
            f"{detection_pipeline} ! "
            f"{user_callback_pipeline}"
        )
        print(f"Pipeline: {pipeline_string}")
        return pipeline_string

    def run(self):
        if self.source_type == "both":
            super().run()
        else:
            super().run()

if __name__ == "__main__":
    project_root = Path(__file__).resolve().parent.parent
    env_file = project_root / ".env"
    os.environ["HAILO_ENV_FILE"] = str(env_file)

    user_data = user_app_callback_class()
    app = GStreamerDetectionApp(app_callback, user_data)
    
    if app.source_type != "both":
        app.run()
