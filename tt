import os
from pathlib import Path
import gi
gi.require_version('Gst', '1.0')
from gi.repository import Gst
import hailo
from hailo_apps.hailo_app_python.core.gstreamer.gstreamer_app import app_callback_class
from hailo_apps.hailo_app_python.apps.detection_simple.pipeline_smartfarm import GStreamerDetectionApp
from PIL import Image, ImageDraw, ImageFont
import numpy as np
import threading
import time
import argparse

# Save paths for both sources
SAVE_PATH_TOPVIEW = "/home/brisk/netdrive/01-Organize/01-Management/01-Data Center/Brisk/06-AI & Machine Learning (D0340)/04-IOT_Smartfarm/picture_result_topview"
SAVE_PATH_SIDEVIEW = "/home/brisk/netdrive/01-Organize/01-Management/01-Data Center/Brisk/06-AI & Machine Learning (D0340)/04-IOT_Smartfarm/picture_result_sideview"

os.makedirs(SAVE_PATH_TOPVIEW, exist_ok=True)
os.makedirs(SAVE_PATH_SIDEVIEW, exist_ok=True)

class user_app_callback_class(app_callback_class):
    def __init__(self, source_type="topview"):
        super().__init__()
        self.source_type = source_type
        self.detection_count = 0

    def get_source_type(self):
        return self.source_type

    def increment_detection(self):
        self.detection_count += 1

    def get_detection_count(self):
        return self.detection_count

def create_app_callback(source_type):
    """Create a callback function for specific source type"""
    
    def app_callback(pad, info, user_data):
        user_data.increment()
        frame_count = user_data.get_count()
        source = user_data.get_source_type()
        
        string_to_print = f"üì∏ [{source.upper()}] Frame count: {frame_count}\n"
        buffer = info.get_buffer()
        
        if buffer is None:
            return Gst.PadProbeReturn.OK
        
        detections = hailo.get_roi_from_buffer(buffer).get_objects_typed(hailo.HAILO_DETECTION)
        
        if detections:
            caps = pad.get_current_caps()
            structure = caps.get_structure(0)
            width = structure.get_value("width")
            height = structure.get_value("height")
            data = buffer.extract_dup(0, buffer.get_size())
            
            np_image = np.frombuffer(data, dtype=np.uint8).reshape((height, width, 3))
            image = Image.fromarray(np_image)
            draw = ImageDraw.Draw(image)
            
            try:
                font = ImageFont.truetype("/usr/share/fonts/truetype/dejavu/DejaVuSans-Bold.ttf", 20)
            except:
                font = ImageFont.load_default()
            
            detection_info = []
            for detection in detections:
                bbox = detection.get_bbox()
                label = detection.get_label()
                confidence = detection.get_confidence()
                
                x1 = int(bbox.xmin() * width)
                y1 = int(bbox.ymin() * height)
                x2 = int(bbox.xmax() * width)
                y2 = int(bbox.ymax() * height)
                
                # Choose color based on source
                color = "blue" if source == "topview" else "red"
                
                draw.rectangle([x1, y1, x2, y2], outline=color, width=2)
                
                text = f"{label} {confidence:.0%}"
                
                bbox_text = draw.textbbox((0, 0), text, font=font)
                text_width = bbox_text[2] - bbox_text[0]
                text_height = bbox_text[3] - bbox_text[1]
                
                text_y = max(y1 - text_height - 5, 0)
                draw.rectangle([x1, text_y, x1 + text_width + 10, text_y + text_height + 5], fill=color)
                
                draw.text((x1 + 5, text_y + 2), text, fill="white", font=font)
                
                detection_info.append({
                    'label': label,
                    'confidence': confidence,
                    'bbox': (x1, y1, x2, y2)
                })
                
                string_to_print += (f"üéØ Detection: {label} Confidence: {confidence:.2f} "
                                  f"Box: ({x1},{y1},{x2},{y2})\n")
            
            # Save to appropriate folder
            save_path = SAVE_PATH_TOPVIEW if source == "topview" else SAVE_PATH_SIDEVIEW
            image_path = os.path.join(save_path, f"result_{source}_{frame_count}.jpg")
            image.save(image_path)
            
            user_data.increment_detection()
            string_to_print += f"üíæ Image saved to: {image_path}\n"
            string_to_print += f"üìä Total detections for {source}: {user_data.get_detection_count()}\n"
            print(string_to_print)
        else:
            print(f"üì∏ [{source.upper()}] Frame count: {frame_count} - ‚ùå No detections")
        
        return Gst.PadProbeReturn.OK
    
    return app_callback

class DualSourceDetectionApp:
    def __init__(self, args):
        self.args = args
        self.topview_app = None
        self.sideview_app = None
        self.topview_thread = None
        self.sideview_thread = None
        
        # Setup environment
        project_root = Path(__file__).resolve().parent.parent
        env_file = project_root / ".env"
        env_path_str = str(env_file)
        os.environ["HAILO_ENV_FILE"] = env_path_str

    def create_gstreamer_app(self, source_type):
        """Create GStreamerDetectionApp with proper arguments"""
        user_data = user_app_callback_class(source_type)
        callback = create_app_callback(source_type)
        
        # Create a mock parser with the arguments
        import argparse
        parser = argparse.ArgumentParser()
        parser.add_argument("--hef-path", default=self.args.hef_path)
        parser.add_argument("--labels-json", default=self.args.labels_json)
        parser.add_argument("--arch", default=getattr(self.args, 'arch', None))
        parser.add_argument("--source-type", default=source_type)
        
        # Parse the arguments to create a namespace object
        parsed_args = parser.parse_args([])
        parsed_args.hef_path = self.args.hef_path
        parsed_args.labels_json = self.args.labels_json
        parsed_args.arch = getattr(self.args, 'arch', None)
        parsed_args.source_type = source_type
        
        app = GStreamerDetectionApp(callback, user_data, parser)
        app.options_menu = parsed_args
        return app

    def run_topview(self):
        """Run topview detection"""
        print("üîµ Starting TOPVIEW detection...")
        try:
            self.topview_app = self.create_gstreamer_app("topview")
            self.topview_app.run()
        except Exception as e:
            print(f"‚ùå Error in topview detection: {e}")

    def run_sideview(self):
        """Run sideview detection"""
        print("üî¥ Starting SIDEVIEW detection...")
        try:
            self.sideview_app = self.create_gstreamer_app("sideview")
            self.sideview_app.run()
        except Exception as e:
            print(f"‚ùå Error in sideview detection: {e}")

    def run_sequential(self):
        """Run both sources sequentially"""
        print("üîÑ Running SEQUENTIAL processing...")
        print("\n" + "="*50)
        print("üì∏ PROCESSING TOPVIEW FIRST")
        print("="*50)
        
        # Run topview first
        self.run_topview()
        
        print("\n" + "="*50)
        print("üì∏ PROCESSING SIDEVIEW SECOND")
        print("="*50)
        
        # Run sideview second
        self.run_sideview()

    def run_parallel(self):
        """Run both sources in parallel threads"""
        print("üîÑ Running PARALLEL processing...")
        
        # Create threads for both sources
        self.topview_thread = threading.Thread(target=self.run_topview, name="TopviewThread")
        self.sideview_thread = threading.Thread(target=self.run_sideview, name="SideviewThread")
        
        # Start both threads
        print("üöÄ Starting both detection threads...")
        self.topview_thread.start()
        time.sleep(2)  # Small delay to avoid resource conflicts
        self.sideview_thread.start()
        
        # Wait for both threads to complete
        print("‚è≥ Waiting for both threads to complete...")
        self.topview_thread.join()
        self.sideview_thread.join()
        
        print("‚úÖ Both detection threads completed!")

    def run_single(self, source_type):
        """Run single source detection"""
        print(f"üîÑ Running SINGLE source: {source_type.upper()}")
        
        if source_type == "topview":
            self.run_topview()
        elif source_type == "sideview":
            self.run_sideview()
        else:
            print(f"‚ùå Invalid source type: {source_type}")

def main():
    parser = argparse.ArgumentParser(description="Dual Source Smart Farm Detection")
    parser.add_argument("--hef-path", required=True, help="Path to HEF model file")
    parser.add_argument("--labels-json", required=True, help="Path to labels JSON file")
    parser.add_argument("--arch", help="Hailo architecture")
    parser.add_argument("--mode", 
                       choices=["sequential", "parallel", "topview", "sideview"],
                       default="sequential",
                       help="Processing mode (default: sequential)")
    
    args = parser.parse_args()
    
    print(f"üöÄ Starting Smart Farm Detection")
    print(f"üìÅ HEF Model: {args.hef_path}")
    print(f"üìÑ Labels: {args.labels_json}")
    print(f"‚öôÔ∏è  Mode: {args.mode}")
    print(f"üèóÔ∏è  Architecture: {args.arch or 'auto-detect'}")
    
    app = DualSourceDetectionApp(args)
    
    if args.mode == "sequential":
        app.run_sequential()
    elif args.mode == "parallel":
        app.run_parallel()
    elif args.mode == "topview":
        app.run_single("topview")
    elif args.mode == "sideview":
        app.run_single("sideview")

if __name__ == "__main__":
    main()
